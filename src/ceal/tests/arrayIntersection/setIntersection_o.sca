####################################
## Intersection between two arrays
##########################################################################
## len(intersection) = min(len(array_1), len(array_2))
##
## if the intersected values are less than len(intersection), 
## the rest will be filled with X (e.g. 999), in order to
## hide the length of the result .
##########################################################################
## array_1 = { 1, 1, 1, 2, 3 }
## array_2 = { 2, 2, 2, 1, 1, 1, 1, 1, 1, 1 }
## intersection = { 1 1 1 2 X }
##########################################################################
## See ./db.opn for input format
##########################################################################


.pragma k=5 r=17 beta=8
.pragma PQ=239.251
.pragma io=ts incdir=../lib/


# Read len(array_1), len(array_2), and compute len(intersection)
.mov21 header_ptr m
.inc header_ptr
.dec header_size
.mov21 header_ptr n
.inc header_ptr
.dec header_size
.minswp m n
.mov m minlen

# set pointerB to point in the start of the second array
.mov ptr ptrA
.mov ptr ptrB
.mov ozero i
l1:
    .inc ptrB
    .inc i
.ifneq i m l1
# Now ptrA points to the start of array A, and ptrB to the start of array B.

.mov ptrB ptrBbu
.mov ozero i
.mov ozero k
outer:                      # for (int i = 0; i < m ; i++) {
    .mov ozero j
    .mov ptrBbu ptrB
    inner:                  #   for (int j = 0 ; j < n ; j++) {

        .mov21 ptrA x
        .mov21 ptrB y

        .mov ozero eq       #       int eq = (arr1[i] == arr2[j]) ? 1 : 0;
        .ifneq x y endif
            .mov oone eq
        endif:

        .omul x eq tmp
        .mov12 tmp res      #       res[k] = eq * arr1[i];
        .add eq res
        .add eq k           #       k += eq;
        .omul X eq tmp
        .add12 tmp ptrB     #       arr2[j] += eq * X;
        .omul XX eq tmp
        .add12 tmp ptrA     #       arr1[i] += eq * XX;

        .inc j
        .inc ptrB
    .ifneq j n inner        #   }
    .inc i
    .inc ptrA
.ifneq i m outer            # }

# padding with X's
padding_loop:               # for ( ; k < minlen ; k++)
    .mov12 X res            #     res[k] = X;
    .inc k
    .inc res
.ifneq k minlen padding_loop

# Print the results
.mov resBu res
.mov ozero k
loop:
    .mov21 res x
    .out x
    .inc res
    .inc k
.ifneq k minlen loop

.halt

# variables
. header_ptr:header_start
. ptr:db_start
. res:result
. resBu:result
. i:0 j:0 k:0 minlen:0 ifelselabel:0
. m:0 n:0 x:0 y:0 tmp:0 eq:0 neq:0
. ptrA:0 ptrB:0 ptrBbu:0
. ozero:0 oone:1
. X:999 XX:9999

# data
header_start:
.include "header.opn"
header_end:
header_size: (header_end - header_start)

db_start:
.include "db.opn"
db_end:
db_size: (db_end - db_start)

.include "secure.lib"

. result:[200]


# int* intersect(int arr1[], int arr2[], int m, int n) {
#     int k = 0;
#     int minlen = (m < n) ? m : n;
#     int *res = malloc(minlen * sizeof(int));
#     for (int i = 0; i < m ; i++) {
#         for (int j = 0 ; j < n ; j++) {
#             int eq = (arr1[i] == arr2[j]) ? 1 : 0;
#             res[k] = eq * arr1[i];
#             k += eq;
#             arr2[j] += eq * X;
#             arr1[i] += eq * XX;
#         }
#     }
#     for ( ; k < minlen ; k++)
#         res[k] = X;
#     return res;
# }
